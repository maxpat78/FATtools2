Advantages of common_getattr & pack technique in respect of property():
- defer unpacking at effective access time
- unpack *once* only what needed
- pack *once* the full buffer

BUGS/TODO: (disk.py)
optimize SetFilePointer speed due to 64-bit upgrading?
reduce real disk seeking with a variable to track disk position and avoid calling system seek?


BUGS/TODO: (Volume.py)
- date/time preservation in copy_tree_out


BUGS/TODO: (FAT.py)
- introduce Checksum from Win7 or crc32 from zlib in short name generator
- RLE mapping of assigned clusters as Chain member, to speed up count_run (and maxrun4len)?
- mark_run for 12-bit? optimized or not?
- caching with simpler dict {start_sector: [decoded_values]} ?
- unique handle to directories (to auto-update once on closing) (copy from exFAT?)?
- check 255 chars limit in nested directories (investigate in exFAT too)
- merge create in open with modes? (exFAT too)
- stat in dirtable? (exFAT too)
- open w/ full path like opendir? (exFAT too)
- must invalidate handle to erased/replaced objects not explicitly closed (really needs auto-updating fields?)?
- pack & co.: update str += str with list join?
- update FAT32 FSInfo?
- parameters {} to tune cluster allocator?
- guard against seek beyond last valid offset (specially in FixedRoot)
- generalize pack() in utils.py


BUGS/TODO: (exFAT.py)
- implement frags, clean & co.
- mkdirs?
- merge exFAT w/ FAT Chain (write) // 31.8.16 bug in FAT alloc prevented this?
- implement set/clear Label (FAT too)
- update space and cluster stats in boot sector?
BITMAP:
- bitmap is FATted, so it's slower: dict{pos:QWORD}?
- defer Bitmap file update (allocation is really showed already by slot or FAT)?
OTHER:
- test 256M limit per directory table?
- parameters {} to tune cluster allocator?
- generalize pack() in utils.py


BUGS/TODO: (Reorder.pyw)
exclude . and .. from subdirs?
use U D T button and eventually other accelerators?


TODO: (partutils.py)
- handle MBR and UEFI partitions
